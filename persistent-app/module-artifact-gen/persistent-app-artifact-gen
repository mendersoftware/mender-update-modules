#!/bin/bash

set -e

show_help() {
  cat << EOF

Tool to generate Mender Artifacts for the persistent-app Update Module

This module deploys files to the persistent data partition, ensuring they
survive rootfs A/B updates. Uses the data-partition software filesystem
namespace for version tracking that persists across system updates.

Usage: $0 [options] input-files... [-- [options-for-mender-artifact]]

    Options:

        -n, --artifact-name     Artifact name (required)
        -t, --device-type       Target device type (required, repeatable)
        -d, --dest-dir          Destination directory on device (required)
                                Must be an absolute path, typically under /data
        -o, --output-path       Path to output file (default: persistent-app.mender)
        --software-name         Software name for provides (optional)
        --software-version      Software version for provides (optional)
        -h, --help              Show help and exit

        input-files             Files or directories to include in the artifact

    Anything after '--' is passed directly to mender-artifact.

Example:

    $0 -n myapp-v1.0.0 -t raspberrypi4 -d /data/myapp \\
       --software-name myapp --software-version 1.0.0 \\
       -o myapp-v1.0.0.mender ./payload/

EOF
}

show_help_and_exit_error() {
  show_help
  exit 1
}

check_dependency() {
  if ! which "$1" > /dev/null; then
    echo "Error: $1 is required but not found." 1>&2
    return 1
  fi
}

if ! check_dependency mender-artifact; then
  echo "Please install mender-artifact: https://docs.mender.io/downloads/workstation-tools#mender-artifact" 1>&2
  exit 1
fi

declare -a device_types
artifact_name=""
dest_dir=""
output_path="persistent-app.mender"
software_name=""
software_version=""
declare -a input_files
passthrough=0
declare -a passthrough_args

while (( "$#" )); do
  if test $passthrough -eq 1; then
    passthrough_args+=("$1")
    shift
    continue
  fi
  case "$1" in
    --device-type | -t)
      if [ -z "$2" ]; then
        show_help_and_exit_error
      fi
      device_types+=("-t" "$2")
      shift 2
      ;;
    --artifact-name | -n)
      if [ -z "$2" ]; then
        show_help_and_exit_error
      fi
      artifact_name=$2
      shift 2
      ;;
    --dest-dir | -d)
      if [ -z "$2" ]; then
        show_help_and_exit_error
      fi
      dest_dir=$2
      shift 2
      ;;
    --output-path | -o)
      if [ -z "$2" ]; then
        show_help_and_exit_error
      fi
      output_path=$2
      shift 2
      ;;
    --software-name)
      if [ -z "$2" ]; then
        show_help_and_exit_error
      fi
      software_name=$2
      shift 2
      ;;
    --software-version)
      if [ -z "$2" ]; then
        show_help_and_exit_error
      fi
      software_version=$2
      shift 2
      ;;
    -h | --help)
      show_help
      exit 0
      ;;
    --)
      passthrough=1
      shift
      ;;
    -*)
      echo "Error: unsupported option $1"
      show_help_and_exit_error
      ;;
    *)
      input_files+=("$1")
      shift
      ;;
  esac
done

# Validate required arguments
if [ -z "${artifact_name}" ]; then
  echo "Error: Artifact name not specified."
  show_help_and_exit_error
fi

if [ ${#device_types[@]} -eq 0 ]; then
  echo "Error: Device type not specified."
  show_help_and_exit_error
fi

if [ -z "${dest_dir}" ]; then
  echo "Error: Destination directory not specified."
  show_help_and_exit_error
fi

if [ ${#input_files[@]} -eq 0 ]; then
  echo "Error: No input files specified."
  show_help_and_exit_error
fi

# Check dest-dir is an absolute path
case $dest_dir in
  /*)
    ;;
  *)
    echo "Error: Destination directory must be an absolute path."
    exit 1
  ;;
esac

# Warn about flattening behavior with multiple inputs
if [ ${#input_files[@]} -gt 1 ]; then
  echo "Warning: Multiple input files/directories specified. All files will be flattened into a single directory." >&2
  echo "         Directory structure will NOT be preserved. See README for details." >&2
fi

# Create temporary working directory
work_dir=$(mktemp -d)
trap 'rm -rf "$work_dir"' EXIT

# Create dest_dir marker file
echo "$dest_dir" > "$work_dir/dest_dir"

# Build file arguments for mender-artifact
declare -a file_args
file_args+=("-f" "$work_dir/dest_dir")

# Process input files
for item in "${input_files[@]}"; do
  if [ -e "$item" ]; then
    if [ -d "$item" ]; then
      # Copy directory contents
      for file in "$item"/*; do
        if [ -e "$file" ]; then
          cp -a "$file" "$work_dir/"
          file_args+=("-f" "$work_dir/$(basename "$file")")
        fi
      done
    else
      # Copy single file
      cp -a "$item" "$work_dir/"
      file_args+=("-f" "$work_dir/$(basename "$item")")
    fi
  else
    echo "Warning: $item does not exist, skipping."
  fi
done

# Build software version arguments
declare -a software_args
if [ -n "$software_name" ]; then
  software_args+=("--software-name" "$software_name")
fi
if [ -n "$software_version" ]; then
  software_args+=("--software-version" "$software_version")
fi

# Generate the artifact
# CRITICAL: --software-filesystem data-partition ensures provides survive rootfs updates
mender-artifact write module-image \
  -T persistent-app \
  "${device_types[@]}" \
  -o "$output_path" \
  -n "$artifact_name" \
  --software-filesystem data-partition \
  "${software_args[@]}" \
  "${file_args[@]}" \
  "${passthrough_args[@]}"

echo "Artifact $output_path generated successfully:"
mender-artifact read "$output_path"

exit 0
